<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Proof of Build</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta
    name="description"
    content="Proof of Build — a Base-native collectible for early miniapp creators and supporters."
  />

  <!-- Open Graph -->
  <meta property="og:title" content="Proof of Build" />
  <meta
    property="og:description"
    content="Mint your Proof of Build — a Base-native collectible for early miniapp builders and supporters."
  />
  <meta property="og:image" content="https://pob-lyart.vercel.app/og.png" />
  <meta property="og:url" content="https://pob-lyart.vercel.app" />
  <meta property="og:type" content="website" />

  <!-- Farcaster Frame (optional, if you add API later) -->
  <meta property="fc:frame" content="vNext" />
  <meta
    property="fc:frame:post_url"
    content="https://pob-lyart.vercel.app/api/webhook"
  />

  <!-- Farcaster MiniApp -->
  <meta
    name="fc:miniapp"
    content='{
      "version":"1",
      "imageUrl":"https://pob-lyart.vercel.app/icon.png",
      "button":{
        "title":"Mint Proof of Build",
        "action":{
          "type":"launch_miniapp",
          "name":"Proof of Build",
          "url":"https://pob-lyart.vercel.app",
          "splashImageUrl":"https://pob-lyart.vercel.app/og.png",
          "splashBackgroundColor":"#020617"
        }
      }
    }'
  />

  <link rel="icon" type="image/png" href="https://pob-lyart.vercel.app/icon.png" />

  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #020617, #020617 75%);
      color: #e5e7eb;
      display: flex;
      justify-content: center;
    }

    main {
      width: 100%;
      max-width: 720px;
      padding: 20px 14px 32px;
    }

    a {
      color: #60a5fa;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }

    .card {
      background: #020617;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 16px 16px 18px;
      margin-bottom: 14px;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.85);
    }

    .header-row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 10px;
    }

    .badge-live {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      padding: 3px 9px;
      border-radius: 999px;
      background: rgba(21, 128, 61, 0.16);
      color: #bbf7d0;
      margin-bottom: 6px;
    }
    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: radial-gradient(circle, #22c55e, #16a34a);
      box-shadow: 0 0 8px #22c55e;
    }

    .icon {
      width: 56px;
      height: 56px;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      object-fit: cover;
      background: #020617;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      color: #f9fafb;
    }

    .subtitle {
      margin: 4px 0 0;
      font-size: 13px;
      color: #9ca3af;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      font-size: 11px;
    }

    .pill {
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: #9ca3af;
    }

    .label {
      font-size: 12px;
      color: #9ca3af;
    }

    .value {
      font-size: 13px;
      color: #e5e7eb;
      font-weight: 600;
      margin-top: 1px;
    }

    .mono {
      font-family: "JetBrains Mono", "Fira Code", monospace;
      font-size: 12px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
      font-size: 13px;
    }

    @media (max-width: 600px) {
      .header-row {
        align-items: flex-start;
      }
      .grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .mint-title {
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 6px;
      color: #e5e7eb;
    }

    .muted {
      font-size: 13px;
      color: #9ca3af;
      margin: 0 0 8px;
    }

    .mint-row {
      display: flex;
      gap: 10px;
      margin-top: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .input-wrap {
      flex: 1 1 140px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #020617;
      padding: 8px 12px;
      min-width: 0;
    }

    .input-wrap input {
      border: none;
      outline: none;
      background: transparent;
      color: #e5e7eb;
      font-size: 15px;
      width: 60px;
    }

    .input-wrap span {
      font-size: 13px;
      color: #9ca3af;
      margin-left: 4px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    #connectBtn {
      background: rgba(37, 99, 235, 0.12);
      border: 1px solid rgba(59, 130, 246, 0.9);
      color: #bfdbfe;
      padding: 8px 14px;
      font-size: 13px;
    }

    #mintBtn {
      background: linear-gradient(135deg, #38bdf8, #2563eb);
      color: #eff6ff;
      box-shadow: 0 10px 30px rgba(37, 99, 235, 0.7);
      min-width: 120px;
    }
    #mintBtn:disabled {
      opacity: 0.7;
      cursor: default;
      box-shadow: none;
    }

    .estimate {
      margin-top: 6px;
      font-size: 12px;
      color: #9ca3af;
    }

    .status {
      margin-top: 6px;
      font-size: 12px;
      min-height: 16px;
    }
    .status.ok {
      color: #4ade80;
    }
    .status.err {
      color: #f97373;
    }

    .progress {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid rgba(55, 65, 81, 0.9);
      overflow: hidden;
      margin-top: 8px;
    }
    .progress-fill {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, #22c55e, #38bdf8);
      box-shadow: 0 0 18px rgba(34, 197, 94, 0.7);
      transition: width 0.4s ease-out;
    }

    footer {
      margin-top: 12px;
      text-align: center;
      font-size: 11px;
      color: #6b7280;
    }
  </style>

  <!-- ethers.js v6 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js"></script>
</head>
<body>
<main>
  <!-- TOP CARD -->
  <section class="card">
    <div class="badge-live">
      <span class="dot"></span>
      Live on Base · Mint for 0.0001 ETH
    </div>

    <div class="header-row">
      <img src="https://pob-lyart.vercel.app/icon.png" class="icon" alt="POB" />
      <div>
        <h1>Proof of Build</h1>
        <p class="subtitle">
          A Base-native collectible for early miniapp creators and supporters.
          Mint once or mint many — keep it as your onchain builder badge.
        </p>
      </div>
    </div>

    <div class="grid">
      <div>
        <div class="label">Contract</div>
        <div class="value mono">
          <a
            href="https://basescan.org/address/0x01b91784C9B80d7fEfb206E2E1FC63ef1616386C"
            target="_blank"
          >0x01b9...6386C</a>
        </div>
      </div>
      <div>
        <div class="label">Network</div>
        <div class="value">Base Mainnet (8453)</div>
      </div>
      <div>
        <div class="label">Price</div>
        <div class="value" id="priceText">0.0001 ETH per NFT</div>
      </div>
      <div>
        <div class="label">Max per wallet</div>
        <div class="value" id="perWalletText">Loading…</div>
      </div>
    </div>

    <div style="margin-top: 10px; display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap;">
      <button id="connectBtn">Connect wallet</button>
      <div class="label" style="flex:1; text-align:right;">
        <span id="youHoldText">You hold: 0 POB</span>
      </div>
    </div>
  </section>

  <!-- MINT CARD -->
  <section class="card">
    <p class="mint-title">Mint your Proof of Build</p>
    <p class="muted">
      Choose how many you want to mint. You’ll receive
      <span class="mono">Proof of Build</span> directly to your address on Base.
    </p>

    <div class="mint-row">
      <div class="input-wrap">
        <input
          id="qtyInput"
          type="number"
          min="1"
          step="1"
          value="1"
          inputmode="numeric"
        />
        <span>NFT</span>
      </div>
      <button id="mintBtn">Mint POB</button>
    </div>

    <div class="estimate" id="estimateText">Estimated: 1 POB · 0.0001 ETH</div>
    <div class="status" id="mintStatus"></div>
  </section>

  <!-- STATS CARD -->
  <section class="card">
    <p class="mint-title">Mint stats</p>
    <p class="muted">On-chain stats for the Proof of Build drop.</p>

    <div class="progress">
      <div id="progressFill" class="progress-fill"></div>
    </div>
    <div class="estimate" id="supplyText">
      Minted: loading…
    </div>
  </section>

  <!-- ABOUT -->
  <section class="card">
    <p class="mint-title">About this drop</p>
    <p class="muted">
      Proof of Build is a simple onchain memento for people who experiment with
      Base miniapps early. Mint is set to <span class="mono">0.0001 ETH</span>,
      with a fixed supply configured on-chain via thirdweb.
    </p>
    <p class="muted" style="margin-top:6px;">
      If you share this link on Warpcast and the preview card doesn’t show,
      make sure there is <strong>no extra space/newline after the URL</strong>
      in your cast.
    </p>
  </section>

  <footer>
    Proof of Build · Base Miniapp · 2025
  </footer>
</main>

<script>
  // --- CONFIG ---
  const CONTRACT_ADDRESS = "0x01b91784C9B80d7fEfb206E2E1FC63ef1616386C";
  const TOKEN_ID = 0n;          // ERC1155 token id
  const CHAIN_ID = 8453;        // Base mainnet
  const CHAIN_ID_HEX = "0x2105"; // 8453 in hex
  const RPC_URL = "https://mainnet.base.org";

  // minimal ABI (read + claim)
  const ABI = [
    "function totalSupply(uint256) view returns (uint256)",
    "function maxTotalSupply(uint256) view returns (uint256)",
    "function balanceOf(address account, uint256 id) view returns (uint256)",
    "function getActiveClaimConditionId(uint256 _tokenId) view returns (uint256)",
    "function getClaimConditionById(uint256 _tokenId, uint256 _conditionId) view returns (tuple(uint256 startTimestamp,uint256 maxClaimableSupply,uint256 supplyClaimed,uint256 quantityLimitPerWallet,bytes32 merkleRoot,uint256 pricePerToken,address currency,string metadata))",
    "function claim(address _receiver,uint256 _tokenId,uint256 _quantity,address _currency,uint256 _pricePerToken,(bytes32[] proof,uint256 quantityLimitPerWallet,uint256 pricePerToken,address currency) _allowlistProof,bytes _data) payable"
  ];

  // --- DOM ---
  const connectBtn = document.getElementById("connectBtn");
  const qtyInput = document.getElementById("qtyInput");
  const mintBtn = document.getElementById("mintBtn");
  const mintStatus = document.getElementById("mintStatus");
  const estimateText = document.getElementById("estimateText");
  const priceText = document.getElementById("priceText");
  const perWalletText = document.getElementById("perWalletText");
  const youHoldText = document.getElementById("youHoldText");
  const supplyText = document.getElementById("supplyText");
  const progressFill = document.getElementById("progressFill");

  // --- STATE ---
  let readProvider;
  let readContract;
  let currentAccount = null;
  let currentPriceWei = null;
  let currentCurrency = null; // address
  let maxPerWallet = null;

  function setStatus(msg, ok) {
    mintStatus.textContent = msg || "";
    mintStatus.className = "status " + (msg ? (ok ? "ok" : "err") : "");
  }

  // read-only provider
  function getReadContract() {
    if (!readProvider) {
      readProvider = new ethers.JsonRpcProvider(RPC_URL);
      readContract = new ethers.Contract(CONTRACT_ADDRESS, ABI, readProvider);
    }
    return readContract;
  }

  async function loadOnchainInfo() {
    try {
      const c = getReadContract();

      const [totalSupplyBN, maxTotalSupplyBN, conditionIdBN] = await Promise.all([
        c.totalSupply(TOKEN_ID),
        c.maxTotalSupply(TOKEN_ID),
        c.getActiveClaimConditionId(TOKEN_ID)
      ]);

      const condition = await c.getClaimConditionById(TOKEN_ID, conditionIdBN);

      const totalSupply = Number(totalSupplyBN);
      let maxSupply = Number(maxTotalSupplyBN);
      if (!maxSupply || maxSupply === 0) {
        // fallback to claim condition if maxTotalSupply is 0
        maxSupply = Number(condition.maxClaimableSupply);
      }

      currentPriceWei = condition.pricePerToken;
      currentCurrency = condition.currency;
      maxPerWallet = Number(condition.quantityLimitPerWallet);

      const priceEth = Number(ethers.formatEther(currentPriceWei));
      priceText.textContent = priceEth.toFixed(4) + " ETH per NFT";

      if (!maxPerWallet || maxPerWallet === 0 || maxPerWallet > 1000000000) {
        perWalletText.textContent = "Unlimited (contract-level)";
      } else {
        perWalletText.textContent = maxPerWallet + " per wallet";
      }

      // progress
      const pct = maxSupply > 0 ? (totalSupply / maxSupply) * 100 : 0;
      progressFill.style.width = Math.min(pct, 100).toFixed(2) + "%";

      supplyText.textContent =
        "Minted: " +
        totalSupply.toLocaleString() +
        " / " +
        (maxSupply > 0 ? maxSupply.toLocaleString() : "∞") +
        " POB" +
        (maxSupply > 0
          ? " (" + pct.toFixed(2) + "%)"
          : "");

      updateEstimate();
    } catch (err) {
      console.error("loadOnchainInfo error", err);
      supplyText.textContent = "Minted: data unavailable";
      priceText.textContent = "Price: data unavailable";
    }
  }

  function updateEstimate() {
    if (!currentPriceWei) {
      estimateText.textContent = "Estimated: loading…";
      return;
    }
    let qty = parseInt(qtyInput.value || "0", 10);
    if (!Number.isFinite(qty) || qty <= 0) {
      estimateText.textContent = "Estimated: –";
      return;
    }

    const totalWei = currentPriceWei * BigInt(qty);
    const totalEth = Number(ethers.formatEther(totalWei));
    estimateText.textContent =
      "Estimated: " + qty + " POB · " + totalEth.toFixed(4) + " ETH";
  }

  async function connectWallet() {
    if (!window.ethereum) {
      alert("No wallet detected. Open this page in Base Wallet, Rainbow, or a browser with MetaMask.");
      return;
    }
    try {
      const accounts = await window.ethereum.request({
        method: "eth_requestAccounts"
      });
      if (!accounts || !accounts.length) return;

      // ensure Base
      const chainIdHex = await window.ethereum.request({
        method: "eth_chainId"
      });
      const current = parseInt(chainIdHex, 16);
      if (current !== CHAIN_ID) {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: CHAIN_ID_HEX }]
        });
      }

      currentAccount = accounts[0];
      const short =
        currentAccount.slice(0, 6) + "..." + currentAccount.slice(-4);
      connectBtn.textContent = short;

      await refreshBalance();
      setStatus("", true);
    } catch (err) {
      console.error("connectWallet error", err);
      setStatus(err.message || "Failed to connect wallet.", false);
    }
  }

  async function refreshBalance() {
    if (!currentAccount) return;
    try {
      const c = getReadContract();
      const balBN = await c.balanceOf(currentAccount, TOKEN_ID);
      const bal = Number(balBN);
      youHoldText.textContent = "You hold: " + bal.toLocaleString() + " POB";
    } catch (err) {
      console.error("balance error", err);
    }
  }

  async function handleMint() {
    if (!window.ethereum) {
      alert("No wallet detected. Open this in Base Wallet or MetaMask.");
      return;
    }
    let qty = parseInt(qtyInput.value || "0", 10);
    if (!Number.isFinite(qty) || qty <= 0) {
      setStatus("Enter a quantity greater than 0.", false);
      return;
    }

    if (!currentPriceWei || !currentCurrency) {
      setStatus("Price data not loaded yet. Please wait a moment.", false);
      return;
    }

    try {
      mintBtn.disabled = true;
      setStatus("Waiting for wallet confirmation…", true);

      const browserProvider = new ethers.BrowserProvider(window.ethereum);
      const network = await browserProvider.getNetwork();
      if (Number(network.chainId) !== CHAIN_ID) {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: CHAIN_ID_HEX }]
        });
      }

      const signer = await browserProvider.getSigner();
      const account = await signer.getAddress();
      currentAccount = account;

      const contract = new ethers.Contract(
        CONTRACT_ADDRESS,
        ABI,
        signer
      );

      const allowlistProof = {
        proof: [],
        quantityLimitPerWallet: 0,
        pricePerToken: currentPriceWei,
        currency: currentCurrency
      };

      const totalValue = currentPriceWei * BigInt(qty);

      const tx = await contract.claim(
        account,
        TOKEN_ID,
        qty,
        currentCurrency,
        currentPriceWei,
        allowlistProof,
        "0x",
        { value: totalValue }
      );

      setStatus("Minting… waiting for confirmation on-chain.", true);
      await tx.wait();
      setStatus("Mint successful! Your Proof of Build is on-chain.", true);

      await Promise.all([loadOnchainInfo(), refreshBalance()]);
    } catch (err) {
      console.error("mint error", err);
      if (err && err.message) {
        setStatus(err.message, false);
      } else {
        setStatus("Mint failed or was rejected.", false);
      }
    } finally {
      mintBtn.disabled = false;
    }
  }

  // --- EVENT BINDINGS ---
  connectBtn.addEventListener("click", connectWallet);
  mintBtn.addEventListener("click", handleMint);
  qtyInput.addEventListener("input", () => {
    if (qtyInput.value === "") return updateEstimate();
    const n = parseInt(qtyInput.value, 10);
    if (!Number.isFinite(n) || n <= 0) {
      qtyInput.value = "1";
    }
    updateEstimate();
  });

  // --- INITIAL LOAD ---
  loadOnchainInfo();
</script>
</body>
</html>
